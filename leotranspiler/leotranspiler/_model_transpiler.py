from ._helper import _get_rounding_decimal_places
from ._leo_helper import _get_leo_integer_type
from ._input_generator import _InputGenerator
import sklearn, math

def _get_model_transpiler(model, validation_data):
    if(isinstance(model, sklearn.tree._classes.DecisionTreeClassifier)):
        return _DecisionTreeTranspiler(model, validation_data)
    else:
        raise ValueError("Model is not supported.")

class _ModelTranspilerBase:
    def __init__(self, model, validation_data):
        self.model = model
        self.validation_data = validation_data
    
    def transpile(self, project_name):
        raise NotImplementedError("This method is not implemented.")
    
    def _numbers_get_leo_type_and_fixed_point_scaling_factor(self):
        minimum_model, maximum_model = self._get_numeric_range_model()
        minimum = minimum_model
        maximum = maximum_model
        if(self.validation_data is not None):
            minimum_data, maximum_data = self._get_numeric_range_data()
            minimum = min(minimum, minimum_data)
            maximum = max(maximum, maximum_data)

        bits_for_integer_part = math.ceil(math.log2(max(abs(minimum), abs(maximum))))
        signed_type_needed = minimum < 0

        # Fixed point parametrization
        max_decimal_places_model = self._get_max_decimal_places_model()
        max_decimal_places_data = 0
        if(self.validation_data is not None):
            max_decimal_places_data = self._get_max_decimal_places_data()
        max_decimal_places = max(max_decimal_places_data, max_decimal_places_model)

        min_decimal_value = 10**(-max_decimal_places)
        fixed_point_min_scaling_exponent = math.log2(1 / min_decimal_value)
        bits_for_fractional_part = math.ceil(fixed_point_min_scaling_exponent)
        fixed_point_scaling_factor = 2**bits_for_fractional_part

        leo_type = _get_leo_integer_type(signed_type_needed, bits_for_integer_part+bits_for_fractional_part)

        self.leo_type = leo_type
        self.fixed_point_scaling_factor = fixed_point_scaling_factor

        print(f"Minimum number: {minimum}, maximum number: {maximum}. Recommended fixed-point scaling factor: {fixed_point_scaling_factor}, required Leo type: {leo_type}")

        return leo_type, fixed_point_scaling_factor
    
    def _get_numeric_range_model(self):
        raise NotImplementedError("This method is not implemented.")

    def _get_numeric_range_data(self):
        return self.validation_data.min(), self.validation_data.max()
    
    def _get_max_decimal_places_model(self):
        raise NotImplementedError("This method is not implemented.")
    
    def _get_max_decimal_places_data(self):
        return max([_get_rounding_decimal_places(val) for val in self.validation_data.ravel()])
    
    def _convert_to_fixed_point(self, value):
        if(hasattr(value, "shape")): # check if value is a numpy array
            return (value * self.fixed_point_scaling_factor).astype(int)
        else:
            return int(round(value * self.fixed_point_scaling_factor))
    
    def convert_computation_base_outputs_to_decimal(self, computation_base):
        computation_base.fixed_point_scaling_factor = self.fixed_point_scaling_factor
        computation_base.output_decimal = self._convert_from_fixed_point(computation_base.output)

    def _convert_from_fixed_point(self, value):
        if(isinstance(value, list)):
            return [self._convert_from_fixed_point(val) for val in value]
        else:
            return value / self.fixed_point_scaling_factor
    
    def _get_fixed_point_and_leo_type(self, value):
        return str(self._convert_to_fixed_point(value)) + self.leo_type
    
    def _merge_into_transpiled_code(self, project_name, circuit_inputs, circuit_outputs, model_logic_snippets):
        code = ""
        code += f"""// This file was automatically generated by the LeoTranspiler.
program {project_name}.aleo {{
    transition main {circuit_inputs} -> {circuit_outputs} {{\n"""
        
        for element in model_logic_snippets:
            if(isinstance(element, str)):
                code += f"""{element}"""
            elif(isinstance(element, _InputGenerator._Input)):
                code += f"""{element.name}"""
            else:
                raise ValueError("Unknown element type in model logic snippets.")
            
        code += f"""    }}
}}"""
        return code
    
    def generate_input(self, features):
        fixed_point_features = self._convert_to_fixed_point(features)
        return self.input_generator.generate_input(fixed_point_features)
    
class _DecisionTreeTranspiler(_ModelTranspilerBase):
    def __init__(self, model, validation_data):
        super().__init__(model, validation_data)
    
    def transpile(self, project_name):
        """
        Transpile a model to Leo.

        Parameters
        ----------
        project_name : str
            The name of the project.

        Returns
        -------
        transpilation_result : str
            The transpiled model.
        """
        
        tree = self.model.tree_
        feature_names = [f"x{i}" for i in range(tree.n_features)]

        # Input generation
        self.input_generator = _InputGenerator()
        for feature_name in feature_names:
            self.input_generator.add_input(self.leo_type)

        decision_tree_logic_snippets = self._transpile_decision_tree_logic_to_leo_code(tree, feature_names, indentation="        ")
        circuit_inputs = "(" + self.input_generator.get_circuit_input_string() + ")"
        circuit_outputs = "(" + self.leo_type + ")" # Todo check multi output decision trees and models

        transpilation_result = self._merge_into_transpiled_code(project_name, circuit_inputs, circuit_outputs, decision_tree_logic_snippets)
        return transpilation_result
        
    def _transpile_decision_tree_logic_to_leo_code(self, tree, feature_names, node=0, indentation=""):
        
        left_child = tree.children_left[node]
        right_child = tree.children_right[node]

        # Base case: leaf node
        if left_child == right_child:  # means it's a leaf
            return [indentation + f"return {self._get_fixed_point_and_leo_type(tree.value[node].argmax())};\n"]

        # Recursive case: internal node
        feature = self.input_generator.use_input(tree.feature[node])
        threshold = tree.threshold[node]

        leo_code_snippets = []

        if node == 0:
            leo_code_snippets += [indentation + "if ", feature, f" <= {self._get_fixed_point_and_leo_type(threshold)} {{\n"]
        else:
            leo_code_snippets += [indentation + "if ", feature, f" <= {self._get_fixed_point_and_leo_type(threshold)} {{\n"]

        leo_code_snippets += self._transpile_decision_tree_logic_to_leo_code(tree, feature_names, left_child, indentation + "    ")
        leo_code_snippets += [indentation + f"}}\n" + indentation + "else {\n"]

        leo_code_snippets += self._transpile_decision_tree_logic_to_leo_code(tree, feature_names, right_child, indentation + "    ")
        leo_code_snippets += [indentation + f"}}\n"]
        return leo_code_snippets
    
    def _get_numeric_range_model(self):
        thresholds = self.model.tree_.threshold
        minimum = min(thresholds)
        maximum = max(thresholds)

        classes = self.model.classes_
        # check if classes are numeric
        if(isinstance(classes[0], int)):
            minimum = min(minimum, min(classes))
            maximum = max(maximum, max(classes))
        
        return minimum, maximum
    
    def _get_max_decimal_places_model(self):
        max_decimal_places = max([_get_rounding_decimal_places(val) for val in self.model.tree_.threshold.ravel()])
        return max_decimal_places